<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID HORROR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            font-family: 'Courier New', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameContainer {
            position: relative;
            width: 800px;
            height: 600px;
            border: 2px solid #300;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        
        #crt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            opacity: 0.7;
        }
        
        #vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px #000;
            pointer-events: none;
            z-index: 11;
        }
        
        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 0, 0, 0.3) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 12;
            opacity: 0.6;
        }
        
        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #f00;
            font-size: 12px;
            text-shadow: 0 0 3px #f00;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border: 1px solid #300;
        }
        
        #fearBar {
            width: 200px;
            height: 8px;
            background: #300;
            margin: 5px 0;
            overflow: hidden;
        }
        
        #fearFill {
            height: 100%;
            background: #f00;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px #f00;
        }
        
        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            background: #000;
            color: #f00;
        }
        
        .title {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #f00;
            animation: flicker 3s infinite;
        }
        
        .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            color: #a00;
            max-width: 600px;
            line-height: 1.4;
        }
        
        .btn {
            background: #300;
            border: 2px solid #f00;
            color: #f00;
            padding: 12px 30px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            cursor: pointer;
            margin-top: 20px;
            text-shadow: 0 0 5px #f00;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: #500;
            box-shadow: 0 0 20px #f00;
        }
        
        #gameOver {
            display: none;
            background: rgba(0, 0, 0, 0.95);
        }
        
        #instructions {
            color: #a00;
            font-size: 14px;
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #300;
            z-index: 20;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
            51% { opacity: 0.3; }
            52% { opacity: 0.7; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #f00;
            font-size: 24px;
            text-shadow: 0 0 5px #f00;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #300;
        }
        
        #level {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #f00;
            font-size: 24px;
            text-shadow: 0 0 5px #f00;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #300;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="crt"></div>
        <div id="vignette"></div>
        <div id="scanlines"></div>
        
        <div id="score">SCORE: 0</div>
        <div id="level">LEVEL: 1</div>
        
        <div id="hud">
            <div>FEAR: <span id="fearPercent">0</span>%</div>
            <div id="fearBar">
                <div id="fearFill"></div>
            </div>
            <div>MONSTERS: <span id="monsterCount">0</span></div>
            <div>KEYS: <span id="keys">0</span>/3</div>
        </div>
        
        <div id="instructions">
            ARROWS/WASD: MOVE<br>
            SHIFT: SPRINT<br>
            E: PICK UP KEY<br>
            FIND 3 KEYS TO ESCAPE
        </div>
        
        <div id="screens">
            <div class="screen" id="startScreen">
                <div class="title">VOID HORROR</div>
                <div class="subtitle">
                    The void consumes all. Find 3 keys to unlock the exit.<br>
                    Monsters hunt you in the dark. Fear grows in their presence.<br>
                    Survive as long as you can.
                </div>
                <button class="btn" id="startBtn">ENTER THE VOID</button>
                <div class="subtitle" style="font-size: 12px; margin-top: 30px; color: #500;">
                    ðŸ”Š Use headphones for immersive experience
                </div>
            </div>
            
            <div class="screen" id="gameOver">
                <div class="title">CONSUMED</div>
                <div class="subtitle" id="deathMessage">The void has taken you.</div>
                <div class="subtitle" style="font-size: 24px; margin: 20px 0;">
                    SCORE: <span id="finalScore">0</span>
                </div>
                <button class="btn" id="restartBtn">TRY AGAIN</button>
            </div>
        </div>
    </div>

    <script>
        // ========================
        // GAME ENGINE
        // ========================
        const Game = {
            // Canvas
            canvas: null,
            ctx: null,
            width: 800,
            height: 600,
            
            // Game state
            running: true,
            score: 0,
            level: 1,
            keysCollected: 0,
            totalKeys: 3,
            fear: 0,
            
            // Player
            player: {
                x: 400,
                y: 300,
                radius: 10,
                speed: 2.5,
                angle: 0,
                moving: false,
                running: false,
                invincible: false
            },
            
            // Map
            tiles: [],
            tileSize: 40,
            mapWidth: 20,
            mapHeight: 15,
            
            // Objects
            monsters: [],
            keys: [],
            exit: null,
            torches: [],
            
            // Audio
            audio: null,
            lastFootstep: 0,
            lastHeartbeat: 0,
            
            // Input
            keysPressed: {},
            
            // Visual effects
            screenShake: 0,
            flashRed: 0,
            
            // Configuration
            config: {
                monsterSpawnRate: 0.02,
                fearIncreasePerMonster: 0.8,
                fearDecreaseRate: 0.3,
                maxMonsters: 15,
                monsterSpeed: 0.8,
                torchRadius: 100
            }
        };

        // ========================
        // AUDIO ENGINE
        // ========================
        class AudioEngine {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.master = this.ctx.createGain();
                    this.master.connect(this.ctx.destination);
                    this.master.gain.value = 0.25;
                    
                    // Start ambient sounds
                    this.startAmbience();
                } catch (e) {
                    console.log("Audio not available");
                    this.ctx = null;
                }
            }
            
            startAmbience() {
                if (!this.ctx) return;
                
                // Low drone
                const drone1 = this.ctx.createOscillator();
                drone1.type = 'sawtooth';
                drone1.frequency.value = 55;
                
                const gain1 = this.ctx.createGain();
                gain1.gain.value = 0.1;
                
                drone1.connect(gain1);
                gain1.connect(this.master);
                drone1.start();
                
                // High drone
                const drone2 = this.ctx.createOscillator();
                drone2.type = 'triangle';
                drone2.frequency.value = 220;
                
                const gain2 = this.ctx.createGain();
                gain2.gain.value = 0.05;
                
                drone2.connect(gain2);
                gain2.connect(this.master);
                drone2.start();
                
                this.ambient = { drone1, drone2, gain1, gain2 };
            }
            
            playFootstep(running = false) {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                // Create noise burst
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 0.08;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                // Highpass filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = running ? 300 : 200;
                
                // Envelope
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(running ? 0.15 : 0.1, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.master);
                
                noise.start(now);
                noise.stop(now + 0.15);
            }
            
            playMonsterSound(distance) {
                if (!this.ctx || Math.random() > 0.3) return;
                
                const now = this.ctx.currentTime;
                
                // Create creepy monster sound
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'sawtooth';
                osc1.frequency.value = 80 + Math.random() * 100;
                
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'sawtooth';
                osc2.frequency.value = 85 + Math.random() * 100;
                
                // Modulator for FM
                const modulator = this.ctx.createOscillator();
                modulator.type = 'sine';
                modulator.frequency.value = 5 + Math.random() * 10;
                
                const modGain = this.ctx.createGain();
                modGain.gain.value = 20 + Math.random() * 30;
                
                // Volume based on distance
                const gain = this.ctx.createGain();
                const volume = Math.max(0.05, 0.3 - (distance / 300));
                gain.gain.value = volume;
                
                modulator.connect(modGain);
                modGain.connect(osc1.frequency);
                modGain.connect(osc2.frequency);
                
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(this.master);
                
                osc1.start(now);
                osc2.start(now);
                modulator.start(now);
                
                const duration = 0.5 + Math.random() * 0.5;
                osc1.stop(now + duration);
                osc2.stop(now + duration);
                modulator.stop(now + duration);
            }
            
            playKeyPickup() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = 400;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                osc.connect(gain);
                gain.connect(this.master);
                
                osc.start(now);
                osc.stop(now + 0.5);
            }
            
            playJumpscare() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                // Loud distorted noise
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                // Distortion
                const distortion = this.ctx.createWaveShaper();
                const curve = new Float32Array(44100);
                for (let i = 0; i < 44100; i++) {
                    const x = (i - 22050) / 22050;
                    curve[i] = Math.tanh(x * 20) * 0.5;
                }
                distortion.curve = curve;
                
                // Envelope
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.8, now + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                
                noise.connect(distortion);
                distortion.connect(gain);
                gain.connect(this.master);
                
                noise.start(now);
                noise.stop(now + 0.6);
            }
            
            playHeartbeat() {
                if (!this.ctx || this.heartbeatActive) return;
                
                this.heartbeatActive = true;
                
                const playPulse = () => {
                    if (!this.ctx) return;
                    
                    const now = this.ctx.currentTime;
                    
                    const osc = this.ctx.createOscillator();
                    osc.frequency.value = 60;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.25, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    
                    osc.connect(gain);
                    gain.connect(this.master);
                    
                    osc.start(now);
                    osc.stop(now + 0.3);
                };
                
                // Double beat
                playPulse();
                setTimeout(() => playPulse(), 120);
                
                setTimeout(() => {
                    this.heartbeatActive = false;
                }, 800);
            }
            
            updateFear(fear) {
                if (!this.ctx || !this.ambient) return;
                
                const intensity = fear / 100;
                
                // Increase ambient volume with fear
                this.ambient.gain1.gain.value = 0.1 + (intensity * 0.2);
                this.ambient.gain2.gain.value = 0.05 + (intensity * 0.1);
                
                // Make audio more distorted with fear
                if (intensity > 0.5 && !this.distortion) {
                    this.addDistortion();
                } else if (intensity <= 0.5 && this.distortion) {
                    this.removeDistortion();
                }
            }
            
            addDistortion() {
                if (!this.ctx) return;
                
                this.distortion = this.ctx.createWaveShaper();
                const curve = new Float32Array(44100);
                for (let i = 0; i < 44100; i++) {
                    const x = (i - 22050) / 22050;
                    curve[i] = x * (1 + Math.abs(x) * 3);
                }
                this.distortion.curve = curve;
                
                // Reconnect audio through distortion
                this.master.disconnect();
                this.master.connect(this.distortion);
                this.distortion.connect(this.ctx.destination);
            }
            
            removeDistortion() {
                if (!this.distortion) return;
                
                this.distortion.disconnect();
                this.master.disconnect();
                this.master.connect(this.ctx.destination);
                this.distortion = null;
            }
            
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        }

        // ========================
        // MAP GENERATION
        // ========================
        function generateMap() {
            Game.tiles = [];
            Game.monsters = [];
            Game.keys = [];
            Game.torches = [];
            
            // Create empty map
            for (let y = 0; y < Game.mapHeight; y++) {
                Game.tiles[y] = [];
                for (let x = 0; x < Game.mapWidth; x++) {
                    // Border walls
                    if (x === 0 || y === 0 || x === Game.mapWidth - 1 || y === Game.mapHeight - 1) {
                        Game.tiles[y][x] = 1; // Wall
                    } else {
                        // Random walls inside
                        Game.tiles[y][x] = Math.random() < 0.2 ? 1 : 0;
                    }
                }
            }
            
            // Ensure player start is clear
            const startX = Math.floor(Game.player.x / Game.tileSize);
            const startY = Math.floor(Game.player.y / Game.tileSize);
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const x = startX + dx;
                    const y = startY + dy;
                    if (x >= 0 && x < Game.mapWidth && y >= 0 && y < Game.mapHeight) {
                        Game.tiles[y][x] = 0;
                    }
                }
            }
            
            // Place exit in random corner
            const corners = [
                [1, 1],
                [Game.mapWidth - 2, 1],
                [1, Game.mapHeight - 2],
                [Game.mapWidth - 2, Game.mapHeight - 2]
            ];
            const exitCorner = corners[Math.floor(Math.random() * corners.length)];
            Game.exit = {
                x: exitCorner[0] * Game.tileSize + Game.tileSize / 2,
                y: exitCorner[1] * Game.tileSize + Game.tileSize / 2
            };
            
            // Clear area around exit
            const exitGridX = Math.floor(Game.exit.x / Game.tileSize);
            const exitGridY = Math.floor(Game.exit.y / Game.tileSize);
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const x = exitGridX + dx;
                    const y = exitGridY + dy;
                    if (x >= 0 && x < Game.mapWidth && y >= 0 && y < Game.mapHeight) {
                        Game.tiles[y][x] = 0;
                    }
                }
            }
            
            // Place keys in random locations
            Game.keysCollected = 0;
            for (let i = 0; i < Game.totalKeys; i++) {
                let keyX, keyY;
                do {
                    keyX = Math.floor(Math.random() * (Game.mapWidth - 2)) + 1;
                    keyY = Math.floor(Math.random() * (Game.mapHeight - 2)) + 1;
                } while (Game.tiles[keyY][keyX] === 1 || 
                         (keyX === startX && keyY === startY) ||
                         (Math.abs(keyX - exitGridX) < 3 && Math.abs(keyY - exitGridY) < 3));
                
                Game.keys.push({
                    x: keyX * Game.tileSize + Game.tileSize / 2,
                    y: keyY * Game.tileSize + Game.tileSize / 2,
                    collected: false
                });
            }
            
            // Place torches
            for (let i = 0; i < 8; i++) {
                let torchX, torchY;
                do {
                    torchX = Math.floor(Math.random() * (Game.mapWidth - 2)) + 1;
                    torchY = Math.floor(Math.random() * (Game.mapHeight - 2)) + 1;
                } while (Game.tiles[torchY][torchX] === 1);
                
                Game.torches.push({
                    x: torchX * Game.tileSize + Game.tileSize / 2,
                    y: torchY * Game.tileSize + Game.tileSize / 2,
                    radius: Game.config.torchRadius,
                    flicker: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn initial monsters
            for (let i = 0; i < 3 + Game.level; i++) {
                spawnMonster();
            }
        }

        function spawnMonster() {
            if (Game.monsters.length >= Game.config.maxMonsters) return;
            
            let x, y;
            do {
                x = Math.random() * Game.width;
                y = Math.random() * Game.height;
            } while (isWall(x, y) || distance(x, y, Game.player.x, Game.player.y) < 200);
            
            Game.monsters.push({
                x: x,
                y: y,
                radius: 12,
                speed: Game.config.monsterSpeed * (0.8 + Math.random() * 0.4),
                angle: Math.random() * Math.PI * 2,
                pulse: Math.random() * Math.PI * 2,
                lastSound: 0,
                type: Math.floor(Math.random() * 3) // Different monster types
            });
        }

        // ========================
        // GAME INITIALIZATION
        // ========================
        function initGame() {
            Game.canvas = document.getElementById('gameCanvas');
            Game.ctx = Game.canvas.getContext('2d');
            Game.canvas.width = Game.width;
            Game.canvas.height = Game.height;
            
            // Setup audio
            Game.audio = new AudioEngine();
            
            // Reset game state
            Game.score = 0;
            Game.level = 1;
            Game.fear = 0;
            Game.player.x = Game.width / 2;
            Game.player.y = Game.height / 2;
            Game.keysPressed = {};
            
            // Generate first level
            generateMap();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // ========================
        // GAME LOGIC
        // ========================
        function update() {
            if (!Game.running) return;
            
            // Update player
            updatePlayer();
            
            // Update monsters
            updateMonsters();
            
            // Check collisions
            checkCollisions();
            
            // Update fear
            updateFear();
            
            // Spawn new monsters
            if (Math.random() < Game.config.monsterSpawnRate) {
                spawnMonster();
            }
            
            // Update visual effects
            updateEffects();
            
            // Update UI
            updateUI();
        }

        function updatePlayer() {
            // Player movement - CIRCLE MOVEMENT
            const speed = Game.player.running ? Game.player.speed * 1.8 : Game.player.speed;
            
            if (Game.keysPressed['w'] || Game.keysPressed['arrowup']) {
                Game.player.y -= speed;
                Game.player.moving = true;
            }
            if (Game.keysPressed['s'] || Game.keysPressed['arrowdown']) {
                Game.player.y += speed;
                Game.player.moving = true;
            }
            if (Game.keysPressed['a'] || Game.keysPressed['arrowleft']) {
                Game.player.x -= speed;
                Game.player.moving = true;
            }
            if (Game.keysPressed['d'] || Game.keysPressed['arrowright']) {
                Game.player.x += speed;
                Game.player.moving = true;
            }
            
            // Keep player in bounds
            Game.player.x = Math.max(Game.player.radius, Math.min(Game.width - Game.player.radius, Game.player.x));
            Game.player.y = Math.max(Game.player.radius, Math.min(Game.height - Game.player.radius, Game.player.y));
            
            // Wall collision
            if (isWall(Game.player.x, Game.player.y)) {
                // Simple collision response - push player out
                const gridX = Math.floor(Game.player.x / Game.tileSize);
                const gridY = Math.floor(Game.player.y / Game.tileSize);
                Game.player.x = (gridX * Game.tileSize) + Game.tileSize / 2;
                Game.player.y = (gridY * Game.tileSize) + Game.tileSize / 2;
            }
            
            // Play footsteps
            if (Game.player.moving && Game.audio) {
                const now = Date.now();
                if (now - Game.lastFootstep > (Game.player.running ? 200 : 400)) {
                    Game.audio.playFootstep(Game.player.running);
                    Game.lastFootstep = now;
                }
            }
            
            Game.player.moving = false;
            
            // Pick up keys with E
            if (Game.keysPressed['e']) {
                for (const key of Game.keys) {
                    if (!key.collected && distance(Game.player.x, Game.player.y, key.x, key.y) < 30) {
                        key.collected = true;
                        Game.keysCollected++;
                        Game.score += 100 * Game.level;
                        if (Game.audio) Game.audio.playKeyPickup();
                        
                        if (Game.keysCollected === Game.totalKeys) {
                            // Exit opens
                            Game.score += 500 * Game.level;
                        }
                        break;
                    }
                }
                Game.keysPressed['e'] = false;
            }
            
            // Check exit
            if (Game.keysCollected === Game.totalKeys && Game.exit && 
                distance(Game.player.x, Game.player.y, Game.exit.x, Game.exit.y) < 30) {
                nextLevel();
            }
        }

        function updateMonsters() {
            for (let i = 0; i < Game.monsters.length; i++) {
                const monster = Game.monsters[i];
                monster.pulse += 0.05;
                
                // Move toward player with some randomness
                const dx = Game.player.x - monster.x;
                const dy = Game.player.y - monster.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    // Add some random movement to make them less predictable
                    const angleToPlayer = Math.atan2(dy, dx);
                    const randomAngle = (Math.random() - 0.5) * 0.5;
                    monster.angle = angleToPlayer + randomAngle;
                    
                    monster.x += Math.cos(monster.angle) * monster.speed;
                    monster.y += Math.sin(monster.angle) * monster.speed;
                }
                
                // Play monster sounds
                if (Game.audio && dist < 200) {
                    const now = Date.now();
                    if (now - monster.lastSound > 2000 + Math.random() * 2000) {
                        Game.audio.playMonsterSound(dist);
                        monster.lastSound = now;
                    }
                }
                
                // Keep monsters in bounds
                monster.x = Math.max(monster.radius, Math.min(Game.width - monster.radius, monster.x));
                monster.y = Math.max(monster.radius, Math.min(Game.height - monster.radius, monster.y));
            }
        }

        function updateFear() {
            // Fear increases with nearby monsters
            let monsterFear = 0;
            for (const monster of Game.monsters) {
                const dist = distance(Game.player.x, Game.player.y, monster.x, monster.y);
                if (dist < 150) {
                    monsterFear += Game.config.fearIncreasePerMonster * (1 - dist / 150);
                }
            }
            
            // Fear increases when running
            if (Game.player.running) {
                monsterFear += 0.5;
            }
            
            // Add fear based on level
            monsterFear += Game.level * 0.1;
            
            // Update fear
            Game.fear += monsterFear;
            Game.fear = Math.max(0, Game.fear - Game.config.fearDecreaseRate);
            Game.fear = Math.min(100, Game.fear);
            
            // Update audio
            if (Game.audio) {
                Game.audio.updateFear(Game.fear);
                
                // Play heartbeat if scared
                if (Game.fear > 50) {
                    const now = Date.now();
                    const interval = 1000 - (Game.fear * 8);
                    if (now - Game.lastHeartbeat > interval) {
                        Game.audio.playHeartbeat();
                        Game.lastHeartbeat = now;
                    }
                }
            }
            
            // Score increases when scared (risk/reward)
            if (monsterFear > 0) {
                Game.score += Math.floor(monsterFear);
            }
        }

        function checkCollisions() {
            if (Game.player.invincible) return;
            
            for (let i = Game.monsters.length - 1; i >= 0; i--) {
                const monster = Game.monsters[i];
                const dist = distance(Game.player.x, Game.player.y, monster.x, monster.y);
                
                if (dist < Game.player.radius + monster.radius) {
                    // Player hit!
                    Game.player.invincible = true;
                    Game.screenShake = 10;
                    Game.flashRed = 10;
                    Game.fear = Math.min(100, Game.fear + 30);
                    
                    if (Game.audio) {
                        Game.audio.playJumpscare();
                    }
                    
                    // Remove monster
                    Game.monsters.splice(i, 1);
                    Game.score += 50;
                    
                    // Brief invincibility
                    setTimeout(() => {
                        Game.player.invincible = false;
                    }, 1000);
                    
                    // Check if player dies
                    if (Game.fear >= 100) {
                        gameOver();
                    }
                    break;
                }
            }
        }

        function updateEffects() {
            // Reduce screen shake
            if (Game.screenShake > 0) {
                Game.screenShake--;
            }
            
            // Reduce flash
            if (Game.flashRed > 0) {
                Game.flashRed--;
            }
            
            // Update torches
            for (const torch of Game.torches) {
                torch.flicker += 0.1;
            }
        }

        function updateUI() {
            document.getElementById('fearPercent').textContent = Math.floor(Game.fear);
            document.getElementById('fearFill').style.width = Game.fear + '%';
            document.getElementById('monsterCount').textContent = Game.monsters.length;
            document.getElementById('keys').textContent = Game.keysCollected;
            document.getElementById('score').textContent = 'SCORE: ' + Game.score;
            document.getElementById('level').textContent = 'LEVEL: ' + Game.level;
        }

        // ========================
        // GAME FLOW
        // ========================
        function nextLevel() {
            Game.level++;
            Game.score += 1000 * (Game.level - 1);
            
            // Increase difficulty
            Game.config.monsterSpeed += 0.1;
            Game.config.monsterSpawnRate += 0.005;
            
            // Generate new map
            generateMap();
            
            // Reset player position to center
            Game.player.x = Game.width / 2;
            Game.player.y = Game.height / 2;
            Game.fear = Math.max(0, Game.fear - 30); // Reduce fear between levels
        }

        function gameOver() {
            Game.running = false;
            document.getElementById('finalScore').textContent = Game.score;
            document.getElementById('gameOver').style.display = 'flex';
            
            if (Game.audio) {
                Game.audio.playJumpscare();
            }
        }

        function restartGame() {
            Game.running = true;
            Game.level = 1;
            Game.score = 0;
            Game.fear = 0;
            Game.keysCollected = 0;
            Game.config.monsterSpeed = 0.8;
            Game.config.monsterSpawnRate = 0.02;
            
            document.getElementById('gameOver').style.display = 'none';
            generateMap();
            Game.player.x = Game.width / 2;
            Game.player.y = Game.height / 2;
        }

        // ========================
        // RENDERING
        // ========================
        function render() {
            const ctx = Game.ctx;
            const width = Game.width;
            const height = Game.height;
            
            // Apply screen shake
            ctx.save();
            if (Game.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * Game.screenShake,
                    (Math.random() - 0.5) * Game.screenShake
                );
            }
            
            // Clear with dark color
            ctx.fillStyle = '#0a080a';
            ctx.fillRect(0, 0, width, height);
            
            // Draw map
            for (let y = 0; y < Game.mapHeight; y++) {
                for (let x = 0; x < Game.mapWidth; x++) {
                    if (Game.tiles[y][x] === 1) {
                        // Wall
                        const screenX = x * Game.tileSize;
                        const screenY = y * Game.tileSize;
                        
                        // Base wall color
                        ctx.fillStyle = '#1a181a';
                        ctx.fillRect(screenX, screenY, Game.tileSize, Game.tileSize);
                        
                        // Wall texture
                        ctx.fillStyle = '#2a282a';
                        ctx.fillRect(screenX + 2, screenY + 2, Game.tileSize - 4, Game.tileSize - 4);
                    }
                }
            }
            
            // Draw torches (light circles)
            for (const torch of Game.torches) {
                const flicker = Math.sin(torch.flicker) * 10;
                const radius = torch.radius + flicker;
                
                const gradient = ctx.createRadialGradient(
                    torch.x, torch.y, 0,
                    torch.x, torch.y, radius
                );
                gradient.addColorStop(0, 'rgba(200, 120, 50, 0.6)');
                gradient.addColorStop(0.5, 'rgba(100, 60, 30, 0.3)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(torch.x - radius, torch.y - radius, radius * 2, radius * 2);
            }
            
            // Draw exit
            if (Game.exit) {
                ctx.fillStyle = Game.keysCollected === Game.totalKeys ? '#0f0' : '#330';
                ctx.beginPath();
                ctx.arc(Game.exit.x, Game.exit.y, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Lock symbol if keys not collected
                if (Game.keysCollected < Game.totalKeys) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(Game.exit.x - 8, Game.exit.y - 8, 16, 10);
                    ctx.fillRect(Game.exit.x - 3, Game.exit.y + 2, 6, 6);
                }
            }
            
            // Draw keys
            for (const key of Game.keys) {
                if (!key.collected) {
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(key.x, key.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Key shape
                    ctx.fillStyle = '#aa0';
                    ctx.fillRect(key.x - 8, key.y - 2, 10, 4);
                    ctx.beginPath();
                    ctx.arc(key.x - 3, key.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw monsters
            for (const monster of Game.monsters) {
                const pulse = Math.sin(monster.pulse) * 3;
                
                // Monster body
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(monster.x, monster.y, monster.radius + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Monster eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(monster.x - 4, monster.y - 3, 3, 0, Math.PI * 2);
                ctx.arc(monster.x + 4, monster.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Monster pupils (always look at player)
                const angle = Math.atan2(Game.player.y - monster.y, Game.player.x - monster.x);
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(monster.x - 4 + Math.cos(angle) * 2, monster.y - 3 + Math.sin(angle) * 2, 1.5, 0, Math.PI * 2);
                ctx.arc(monster.x + 4 + Math.cos(angle) * 2, monster.y - 3 + Math.sin(angle) * 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Monster mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(monster.x, monster.y + 5, 5, 0.2, Math.PI - 0.2);
                ctx.stroke();
            }
            
            // Draw player
            if (Game.player.invincible && Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.fillStyle = '#fff';
            } else {
                ctx.fillStyle = '#0af';
            }
            
            ctx.beginPath();
            ctx.arc(Game.player.x, Game.player.y, Game.player.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Player eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(Game.player.x - 3, Game.player.y - 2, 3, 0, Math.PI * 2);
            ctx.arc(Game.player.x + 3, Game.player.y - 2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Player pupils
            const mouseX = Game.player.x + Math.cos(Game.player.angle) * 50;
            const mouseY = Game.player.y + Math.sin(Game.player.angle) * 50;
            const lookAngle = Math.atan2(mouseY - Game.player.y, mouseX - Game.player.x);
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(Game.player.x - 3 + Math.cos(lookAngle) * 1.5, Game.player.y - 2 + Math.sin(lookAngle) * 1.5, 1.5, 0, Math.PI * 2);
            ctx.arc(Game.player.x + 3 + Math.cos(lookAngle) * 1.5, Game.player.y - 2 + Math.sin(lookAngle) * 1.5, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Player direction indicator
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(Game.player.x, Game.player.y);
            ctx.lineTo(
                Game.player.x + Math.cos(Game.player.angle) * 20,
                Game.player.y + Math.sin(Game.player.angle) * 20
            );
            ctx.stroke();
            
            // Update player angle for circle movement
            Game.player.angle += 0.02;
            
            // Red flash if hit
            if (Game.flashRed > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${Game.flashRed / 30})`;
                ctx.fillRect(0, 0, width, height);
            }
            
            // Fear overlay
            if (Game.fear > 30) {
                const alpha = (Game.fear - 30) / 70 * 0.4;
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, width, height);
            }
            
            // Fog of war (visibility based on torches)
            drawFogOfWar(ctx);
            
            ctx.restore();
        }

        function drawFogOfWar(ctx) {
            // Create gradient for visibility
            for (const torch of Game.torches) {
                const flicker = Math.sin(torch.flicker) * 10;
                const radius = torch.radius + flicker;
                
                const gradient = ctx.createRadialGradient(
                    torch.x, torch.y, radius * 0.7,
                    torch.x, torch.y, radius
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(torch.x - radius, torch.y - radius, radius * 2, radius * 2);
            }
            
            // Player visibility
            const playerRadius = 60;
            const gradient = ctx.createRadialGradient(
                Game.player.x, Game.player.y, playerRadius * 0.5,
                Game.player.x, Game.player.y, playerRadius
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(Game.player.x - playerRadius, Game.player.y - playerRadius, playerRadius * 2, playerRadius * 2);
            
            // Overall dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, Game.width, Game.height);
        }

        // ========================
        // GAME LOOP
        // ========================
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ========================
        // INPUT HANDLING
        // ========================
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            Game.keysPressed[key] = true;
            
            if (key === 'shift') {
                Game.player.running = true;
            }
            
            if (key === 'r' && !Game.running) {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            Game.keysPressed[key] = false;
            
            if (key === 'shift') {
                Game.player.running = false;
            }
        });

        // Mouse movement for looking
        document.addEventListener('mousemove', (e) => {
            const rect = Game.canvas?.getBoundingClientRect();
            if (rect) {
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                Game.player.angle = Math.atan2(mouseY - Game.player.y, mouseX - Game.player.x);
            }
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').classList.add('hidden');
            initGame();
            
            // Activate audio
            if (Game.audio) {
                Game.audio.resume();
            }
        });

        // Restart button
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        // Activate audio on first click
        document.addEventListener('click', () => {
            if (Game.audio) {
                Game.audio.resume();
            }
        }, { once: true });

        // ========================
        // UTILITY FUNCTIONS
        // ========================
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        function isWall(x, y) {
            const gridX = Math.floor(x / Game.tileSize);
            const gridY = Math.floor(y / Game.tileSize);
            
            if (gridX < 0 || gridX >= Game.mapWidth || gridY < 0 || gridY >= Game.mapHeight) {
                return true;
            }
            
            return Game.tiles[gridY][gridX] === 1;
        }
    </script>
</body>
</html>
