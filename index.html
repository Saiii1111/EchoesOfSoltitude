<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHOES OF SOLITUDE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameContainer {
            position: relative;
            width: 960px;
            height: 720px;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            border: 2px solid #0f0;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 0, 0, 0.15) 50%
            );
            background-size: 100% 4px;
            opacity: 0.7;
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle at center,
                transparent 30%,
                rgba(0, 0, 0, 0.8) 100%
            );
        }
        
        .grain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" stitchTiles="stitch"/></filter><rect width="100" height="100" filter="url(%23noise)" opacity="0.12"/></svg>');
            opacity: 0.1;
            mix-blend-mode: overlay;
        }
        
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-size: 14px;
            text-shadow: 0 0 3px #0f0, 0 0 6px #0f0;
            z-index: 20;
            background: rgba(0, 20, 0, 0.5);
            padding: 10px 15px;
            border: 1px solid #0f0;
            border-radius: 3px;
            line-height: 1.5;
        }
        
        #fearMeter {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #f00;
            border-radius: 3px;
            padding: 8px 12px;
            z-index: 20;
        }
        
        .meterLabel {
            color: #f00;
            font-size: 12px;
            text-shadow: 0 0 3px #f00;
            margin-bottom: 5px;
            letter-spacing: 1px;
        }
        
        .meterBar {
            height: 8px;
            background: rgba(40, 0, 0, 0.8);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .meterFill {
            height: 100%;
            background: linear-gradient(90deg, #600, #f00);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 6px #f00;
        }
        
        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 40px;
            background: #000;
        }
        
        #startScreen {
            color: #0f0;
        }
        
        #gameOverScreen, #winScreen {
            display: none;
            background: rgba(0, 0, 0, 0.95);
        }
        
        #gameOverScreen { color: #f00; }
        #winScreen { color: #0f0; }
        
        .title {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px currentColor;
            letter-spacing: 4px;
            animation: flicker 4s infinite;
        }
        
        .subtitle {
            font-size: 18px;
            margin-bottom: 40px;
            color: #aaa;
            max-width: 700px;
            line-height: 1.6;
        }
        
        .message {
            font-size: 28px;
            margin-bottom: 30px;
            max-width: 600px;
            line-height: 1.4;
        }
        
        .btn {
            background: transparent;
            border: 2px solid currentColor;
            color: inherit;
            padding: 15px 40px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            margin-top: 30px;
            text-shadow: 0 0 5px currentColor;
            box-shadow: 0 0 15px currentColor;
            transition: all 0.3s;
            letter-spacing: 2px;
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 25px currentColor;
            transform: scale(1.05);
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #0a0;
            font-size: 12px;
            text-align: right;
            z-index: 20;
            background: rgba(0, 20, 0, 0.5);
            padding: 10px 15px;
            border: 1px solid #0a0;
            border-radius: 3px;
            line-height: 1.5;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            2% { opacity: 0.8; }
            4% { opacity: 1; }
            30% { opacity: 0.9; }
            32% { opacity: 0.4; }
            34% { opacity: 0.9; }
            80% { opacity: 1; }
            82% { opacity: 0.6; }
            84% { opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0a0;
            font-size: 12px;
            z-index: 20;
            background: rgba(0, 20, 0, 0.5);
            padding: 10px;
            border: 1px solid #0a0;
            border-radius: 3px;
            display: none;
        }
        
        #instructions.show {
            display: block;
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="overlay">
            <div class="scanlines"></div>
            <div class="vignette"></div>
            <div class="grain"></div>
        </div>
        
        <div id="ui">
            <div>OBJECTIVE: FIND THE GREEN EXIT</div>
            <div>ENTITIES ACTIVE: <span id="entityCount">3</span></div>
            <div>STATUS: <span id="status">EXPLORING</span></div>
        </div>
        
        <div id="fearMeter">
            <div class="meterLabel">FEAR LEVEL</div>
            <div class="meterBar">
                <div class="meterFill" id="fearFill"></div>
            </div>
            <div class="meterLabel" id="fearText">0%</div>
        </div>
        
        <div id="instructions" class="show">
            USE WASD TO MOVE<br>
            SHIFT TO RUN<br>
            R TO RESTART
        </div>
        
        <div class="controls">
            <div>WASD - MOVE</div>
            <div>SHIFT - RUN</div>
            <div>R - RESTART</div>
        </div>
        
        <div id="screens">
            <div class="screen" id="startScreen">
                <div class="title">ECHOES OF SOLITUDE</div>
                <div class="subtitle">
                    You wake in the endless corridors. The walls whisper.<br>
                    Find the glowing exit before the entities find you.<br>
                    Running increases fear. Fear attracts them.<br>
                    They distort reality when near. Trust nothing.
                </div>
                <button class="btn" id="startBtn">BEGIN</button>
                <div class="subtitle" style="font-size: 14px; margin-top: 40px; color: #666;">
                    ðŸ”Š Use headphones for full effect<br>
                    Click anywhere to activate audio
                </div>
            </div>
            
            <div class="screen" id="gameOverScreen">
                <div class="title">ENTITY CONSUMED YOU</div>
                <div class="message">The distortion became your reality.</div>
                <button class="btn" id="restartBtn">TRY AGAIN</button>
            </div>
            
            <div class="screen" id="winScreen">
                <div class="title">ESCAPE ACHIEVED</div>
                <div class="message">You found the exit. For now.</div>
                <button class="btn" id="playAgainBtn">CONTINUE</button>
            </div>
        </div>
    </div>

    <script>
        // ========================
        // GAME STATE
        // ========================
        const Game = {
            // Canvas
            canvas: null,
            ctx: null,
            width: 320,
            height: 240,
            scale: 3,
            
            // Player
            player: {
                x: 50,
                y: 50,
                size: 6,
                speed: 1.2,
                running: false,
                moving: false
            },
            
            // Exit
            exit: {
                x: 250,
                y: 180,
                size: 10,
                found: false
            },
            
            // Entities
            entities: [],
            walls: [],
            lights: [],
            
            // Game state
            fear: 0,
            gameOver: false,
            won: false,
            gameStarted: false,
            
            // Input
            keys: {},
            
            // Audio
            audio: null,
            lastFootstep: 0,
            lastHeartbeat: 0,
            
            // Visual effects
            flicker: 0,
            shake: { x: 0, y: 0 },
            time: 0,
            
            // Configuration
            config: {
                playerRunSpeed: 2.2,
                entitySpeed: 0.3,
                fearIncreaseRun: 0.4,
                fearIncreaseEntity: 0.6,
                fearDecay: 0.15,
                entitySpawnFear: 65,
                maxEntities: 5,
                heartbeatThreshold: 45
            }
        };

        // ========================
        // SIMPLE AUDIO SYSTEM
        // ========================
        class AudioSystem {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.master = this.ctx.createGain();
                    this.master.connect(this.ctx.destination);
                    this.master.gain.value = 0.2;
                    
                    // Start ambient
                    this.startAmbient();
                    console.log("Audio ready");
                } catch (e) {
                    console.log("Audio not available");
                    this.ctx = null;
                }
            }
            
            startAmbient() {
                if (!this.ctx) return;
                
                // Main drone
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'sawtooth';
                osc1.frequency.value = 60;
                
                const gain1 = this.ctx.createGain();
                gain1.gain.value = 0.06;
                
                osc1.connect(gain1);
                gain1.connect(this.master);
                osc1.start();
                
                // Second detuned oscillator
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'sawtooth';
                osc2.frequency.value = 62;
                
                const gain2 = this.ctx.createGain();
                gain2.gain.value = 0.04;
                
                osc2.connect(gain2);
                gain2.connect(this.master);
                osc2.start();
                
                this.ambient = { osc1, osc2, gain1, gain2 };
            }
            
            playFootstep(running = false) {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                // Create noise burst
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 0.1;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                // Filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = running ? 200 : 120;
                
                // Envelope
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(running ? 0.15 : 0.1, now + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.master);
                
                noise.start(now);
                noise.stop(now + 0.2);
            }
            
            playHeartbeat() {
                if (!this.ctx || this.heartbeatActive) return;
                
                this.heartbeatActive = true;
                
                const playPulse = () => {
                    if (!this.ctx) return;
                    
                    const now = this.ctx.currentTime;
                    
                    const osc = this.ctx.createOscillator();
                    osc.frequency.value = 70;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    
                    osc.connect(gain);
                    gain.connect(this.master);
                    
                    osc.start(now);
                    osc.stop(now + 0.25);
                };
                
                // Double beat
                playPulse();
                setTimeout(() => {
                    if (this.ctx) playPulse();
                }, 120);
                
                setTimeout(() => {
                    this.heartbeatActive = false;
                }, 800);
            }
            
            playEntitySound(distance) {
                if (!this.ctx || Math.random() > 0.3) return;
                
                const now = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = 100 + Math.random() * 400;
                
                const gain = this.ctx.createGain();
                const volume = Math.max(0.03, 0.15 - (distance / 200));
                gain.gain.value = volume;
                
                osc.connect(gain);
                gain.connect(this.master);
                
                osc.start(now);
                osc.stop(now + 0.5 + Math.random());
            }
            
            playJumpscare() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                
                // Loud noise burst
                const noise = this.ctx.createBufferSource();
                const bufferSize = this.ctx.sampleRate * 0.4;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                // Distortion
                const distortion = this.ctx.createWaveShaper();
                const curve = new Float32Array(44100);
                for (let i = 0; i < 44100; i++) {
                    const x = (i - 22050) / 22050;
                    curve[i] = Math.atan(x * 15) * 0.5;
                }
                distortion.curve = curve;
                
                // Volume envelope
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.8, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
                
                noise.connect(distortion);
                distortion.connect(gain);
                gain.connect(this.master);
                
                noise.start(now);
                noise.stop(now + 0.7);
            }
            
            updateFear(fear) {
                if (!this.ctx || !this.ambient) return;
                
                const intensity = fear / 100;
                
                // Increase ambient volume with fear
                this.ambient.gain1.gain.value = 0.06 + (intensity * 0.1);
                this.ambient.gain2.gain.value = 0.04 + (intensity * 0.08);
                
                // Increase master volume slightly with fear
                this.master.gain.value = 0.2 + (intensity * 0.1);
            }
            
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        }

        // ========================
        // GAME INITIALIZATION - FIXED
        // ========================
        function initGame() {
            console.log("Initializing game...");
            
            // Setup canvas
            Game.canvas = document.getElementById('gameCanvas');
            Game.ctx = Game.canvas.getContext('2d');
            
            // Set canvas size
            Game.canvas.width = Game.width;
            Game.canvas.height = Game.height;
            Game.canvas.style.width = `${Game.width * Game.scale}px`;
            Game.canvas.style.height = `${Game.height * Game.scale}px`;
            
            // Setup audio
            Game.audio = new AudioSystem();
            
            // Reset game state
            resetGame();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
            
            console.log("Game initialized");
        }

        function resetGame() {
            // Reset player
            Game.player.x = 50;
            Game.player.y = 50;
            Game.player.running = false;
            Game.player.moving = false;
            
            // Reset exit
            Game.exit.x = Game.width - 70;
            Game.exit.y = Game.height - 70;
            Game.exit.found = false;
            
            // Clear arrays
            Game.entities = [];
            Game.walls = [];
            Game.lights = [];
            
            // Reset game state
            Game.fear = 0;
            Game.gameOver = false;
            Game.won = false;
            Game.time = 0;
            
            // Create border walls
            Game.walls = [
                { x: -10, y: -10, w: Game.width + 20, h: 10 },
                { x: -10, y: Game.height, w: Game.width + 20, h: 10 },
                { x: -10, y: 0, w: 10, h: Game.height },
                { x: Game.width, y: 0, w: 10, h: Game.height }
            ];
            
            // Add random walls
            for (let i = 0; i < 10; i++) {
                const x = 30 + Math.random() * (Game.width - 60);
                const y = 30 + Math.random() * (Game.height - 60);
                const w = 15 + Math.random() * 40;
                const h = 15 + Math.random() * 40;
                
                // Don't block start or exit
                if (distance(x, y, Game.player.x, Game.player.y) > 40 && 
                    distance(x, y, Game.exit.x, Game.exit.y) > 40) {
                    Game.walls.push({ x, y, w, h });
                }
            }
            
            // Add lights
            for (let i = 0; i < 8; i++) {
                Game.lights.push({
                    x: 20 + Math.random() * (Game.width - 40),
                    y: 20 + Math.random() * (Game.height - 40),
                    radius: 10 + Math.random() * 20,
                    intensity: 0.3 + Math.random() * 0.4
                });
            }
            
            // Add entities
            for (let i = 0; i < 3; i++) {
                spawnEntity();
            }
            
            // Update UI
            updateUI();
            
            // Hide instructions after 5 seconds
            setTimeout(() => {
                document.getElementById('instructions').classList.remove('show');
            }, 5000);
        }

        function spawnEntity() {
            if (Game.entities.length >= Game.config.maxEntities) return;
            
            let x, y;
            do {
                x = 40 + Math.random() * (Game.width - 80);
                y = 40 + Math.random() * (Game.height - 80);
            } while (distance(x, y, Game.player.x, Game.player.y) < 60 ||
                     distance(x, y, Game.exit.x, Game.exit.y) < 60);
            
            Game.entities.push({
                x, y,
                speed: Game.config.entitySpeed * (0.8 + Math.random() * 0.4),
                active: true,
                pulse: Math.random() * Math.PI * 2,
                lastSound: 0
            });
        }

        // ========================
        // GAME UPDATE
        // ========================
        function update(deltaTime) {
            if (Game.gameOver || Game.won) return;
            
            Game.time += deltaTime;
            
            // Update player movement
            updatePlayer();
            
            // Update fear
            updateFear();
            
            // Update entities
            updateEntities();
            
            // Check collisions
            checkCollisions();
            
            // Check win condition
            if (distance(Game.player.x, Game.player.y, Game.exit.x, Game.exit.y) < 20) {
                winGame();
            }
            
            // Update effects
            updateEffects();
            
            // Update UI
            updateUI();
        }

        function updatePlayer() {
            const speed = Game.player.running ? Game.config.playerRunSpeed : Game.player.speed;
            const oldX = Game.player.x;
            const oldY = Game.player.y;
            
            // Movement
            if (Game.keys['w'] || Game.keys['arrowup']) {
                Game.player.y -= speed;
                Game.player.moving = true;
            }
            if (Game.keys['s'] || Game.keys['arrowdown']) {
                Game.player.y += speed;
                Game.player.moving = true;
            }
            if (Game.keys['a'] || Game.keys['arrowleft']) {
                Game.player.x -= speed;
                Game.player.moving = true;
            }
            if (Game.keys['d'] || Game.keys['arrowright']) {
                Game.player.x += speed;
                Game.player.moving = true;
            }
            
            // Keep in bounds
            Game.player.x = clamp(Game.player.x, 10, Game.width - 10);
            Game.player.y = clamp(Game.player.y, 10, Game.height - 10);
            
            // Wall collision
            for (const wall of Game.walls) {
                if (rectCircleCollision(wall, Game.player)) {
                    Game.player.x = oldX;
                    Game.player.y = oldY;
                    break;
                }
            }
            
            // Play footsteps
            if (Game.player.moving && Game.audio) {
                const now = Date.now();
                const interval = Game.player.running ? 300 : 500;
                if (now - Game.lastFootstep > interval) {
                    Game.audio.playFootstep(Game.player.running);
                    Game.lastFootstep = now;
                }
            }
        }

        function updateFear() {
            // Increase fear if running
            if (Game.player.running) {
                Game.fear += Game.config.fearIncreaseRun;
            }
            
            // Increase fear from nearby entities
            for (const entity of Game.entities) {
                if (!entity.active) continue;
                
                const dist = distance(entity.x, entity.y, Game.player.x, Game.player.y);
                if (dist < 120) {
                    Game.fear += Game.config.fearIncreaseEntity * (1 - dist / 120);
                }
            }
            
            // Natural decay
            Game.fear = Math.max(0, Game.fear - Game.config.fearDecay);
            Game.fear = Math.min(100, Game.fear);
            
            // Update audio
            if (Game.audio) {
                Game.audio.updateFear(Game.fear);
                
                // Play heartbeat if scared
                if (Game.fear > Game.config.heartbeatThreshold) {
                    const now = Date.now();
                    const interval = 1000 - (Game.fear * 7);
                    if (now - Game.lastHeartbeat > interval) {
                        Game.audio.playHeartbeat();
                        Game.lastHeartbeat = now;
                    }
                }
            }
            
            // Spawn new entity if fear is high
            if (Game.fear > Game.config.entitySpawnFear && 
                Game.entities.length < Game.config.maxEntities &&
                Math.random() < 0.008) {
                spawnEntity();
            }
        }

        function updateEntities() {
            for (const entity of Game.entities) {
                if (!entity.active) continue;
                
                entity.pulse += 0.03;
                
                // Move toward player
                const dx = Game.player.x - entity.x;
                const dy = Game.player.y - entity.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const speed = entity.speed * (1 + Game.fear / 150);
                    entity.x += (dx / dist) * speed;
                    entity.y += (dy / dist) * speed;
                }
                
                // Wall collision
                for (const wall of Game.walls) {
                    if (rectCircleCollision(wall, entity)) {
                        entity.x -= (dx / dist) * 3;
                        entity.y -= (dy / dist) * 3;
                    }
                }
                
                // Play sound if close
                if (dist < 100 && Game.audio) {
                    const now = Date.now();
                    if (now - entity.lastSound > 3000) {
                        Game.audio.playEntitySound(dist);
                        entity.lastSound = now;
                    }
                }
            }
        }

        function checkCollisions() {
            for (const entity of Game.entities) {
                if (!entity.active) continue;
                
                const dist = distance(entity.x, entity.y, Game.player.x, Game.player.y);
                if (dist < 15) {
                    gameOver();
                    return;
                }
            }
        }

        function updateEffects() {
            // Screen shake based on fear
            if (Game.fear > 60) {
                Game.shake.x = (Math.random() - 0.5) * (Game.fear / 100) * 3;
                Game.shake.y = (Math.random() - 0.5) * (Game.fear / 100) * 3;
            } else {
                Game.shake.x = 0;
                Game.shake.y = 0;
            }
            
            // Flicker based on fear
            Game.flicker = Game.fear > 40 ? Math.random() * (Game.fear / 100) * 0.2 : 0;
        }

        function updateUI() {
            document.getElementById('entityCount').textContent = Game.entities.length;
            document.getElementById('fearText').textContent = Math.floor(Game.fear) + '%';
            document.getElementById('fearFill').style.width = Game.fear + '%';
            
            // Update status
            let status = 'EXPLORING';
            if (Game.player.running) status = 'RUNNING';
            if (Game.fear > 70) status = 'PANIC';
            if (Game.entities.some(e => distance(e.x, e.y, Game.player.x, Game.player.y) < 60)) {
                status = 'ENTITY NEARBY';
            }
            document.getElementById('status').textContent = status;
        }

        // ========================
        // RENDERING
        // ========================
        function render() {
            const ctx = Game.ctx;
            const width = Game.width;
            const height = Game.height;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);
            
            // Apply screen shake
            ctx.save();
            ctx.translate(Game.shake.x, Game.shake.y);
            
            // Draw floor
            ctx.fillStyle = '#121220';
            ctx.fillRect(0, 0, width, height);
            
            // Draw walls
            ctx.fillStyle = '#1a1a2a';
            for (const wall of Game.walls) {
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
                
                // Wall texture
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(wall.x + 1, wall.y + 1, wall.w - 2, wall.h - 2);
                ctx.fillStyle = '#1a1a2a';
            }
            
            // Draw lights
            for (const light of Game.lights) {
                const gradient = ctx.createRadialGradient(
                    light.x, light.y, 0,
                    light.x, light.y, light.radius
                );
                gradient.addColorStop(0, `rgba(120, 100, 80, ${light.intensity})`);
                gradient.addColorStop(0.6, `rgba(80, 60, 40, ${light.intensity * 0.6})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(light.x - light.radius, light.y - light.radius, 
                           light.radius * 2, light.radius * 2);
            }
            
            // Draw exit
            if (!Game.exit.found) {
                const pulse = 0.5 + Math.sin(Game.time * 0.004) * 0.4;
                ctx.fillStyle = `rgba(0, 255, 0, ${pulse})`;
                ctx.beginPath();
                ctx.arc(Game.exit.x, Game.exit.y, Game.exit.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow
                ctx.fillStyle = `rgba(0, 255, 0, 0.1)`;
                ctx.beginPath();
                ctx.arc(Game.exit.x, Game.exit.y, 20, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw entities
            for (const entity of Game.entities) {
                if (!entity.active) continue;
                
                const dist = distance(entity.x, entity.y, Game.player.x, Game.player.y);
                if (dist < 140) {
                    const intensity = 1 - (dist / 140);
                    
                    // Create distortion effect
                    ctx.save();
                    
                    // Clip circle
                    ctx.beginPath();
                    ctx.arc(entity.x, entity.y, 25, 0, Math.PI * 2);
                    ctx.clip();
                    
                    // Draw offset image for distortion
                    const offset = Math.sin(entity.pulse) * 4 * intensity;
                    ctx.drawImage(Game.canvas, 
                        entity.x - 30, entity.y - 30, 60, 60,
                        entity.x - 30 + offset, entity.y - 30 + offset, 60, 60);
                    
                    ctx.restore();
                    
                    // Entity indicator
                    if (dist < 80) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${0.15 * intensity})`;
                        ctx.beginPath();
                        ctx.arc(entity.x, entity.y, 3 + Math.sin(entity.pulse) * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw player
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(Game.player.x, Game.player.y, Game.player.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Player direction indicator
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(Game.player.x, Game.player.y);
            ctx.lineTo(
                Game.player.x + Math.cos(Game.time * 0.008) * 12,
                Game.player.y + Math.sin(Game.time * 0.008) * 12
            );
            ctx.stroke();
            
            // Fear overlay
            if (Game.fear > 40) {
                const alpha = (Game.fear - 40) / 60 * 0.35;
                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                ctx.fillRect(0, 0, width, height);
            }
            
            // Flicker overlay
            if (Game.flicker > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${Game.flicker})`;
                ctx.fillRect(0, 0, width, height);
            }
            
            ctx.restore();
        }

        // ========================
        // GAME FLOW
        // ========================
        function gameOver() {
            Game.gameOver = true;
            
            if (Game.audio) {
                Game.audio.playJumpscare();
            }
            
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function winGame() {
            Game.won = true;
            Game.exit.found = true;
            document.getElementById('winScreen').style.display = 'flex';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
            resetGame();
        }

        // ========================
        // GAME LOOP
        // ========================
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = Math.min(currentTime - lastTime, 100) / 1000;
            lastTime = currentTime;
            
            if (Game.gameStarted) {
                update(deltaTime);
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ========================
        // INPUT HANDLING
        // ========================
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            Game.keys[key] = true;
            
            if (key === 'shift') {
                Game.player.running = true;
            }
            
            if (key === 'r') {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            Game.keys[key] = false;
            
            if (key === 'shift') {
                Game.player.running = false;
            }
        });

        // Start button
        document.getElementById('startBtn').addEventListener('click', () => {
            console.log("Start button clicked");
            document.getElementById('startScreen').classList.add('hidden');
            Game.gameStarted = true;
            initGame();
        });

        // Restart buttons
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('playAgainBtn').addEventListener('click', restartGame);

        // Activate audio on click
        document.addEventListener('click', () => {
            if (Game.audio) {
                Game.audio.resume();
            }
        }, { once: true });

        // ========================
        // UTILITY FUNCTIONS
        // ========================
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        
        function rectCircleCollision(rect, circle) {
            const dx = Math.abs(circle.x - (rect.x + rect.w / 2));
            const dy = Math.abs(circle.y - (rect.y + rect.h / 2));
            
            if (dx > (rect.w / 2 + circle.size)) return false;
            if (dy > (rect.h / 2 + circle.size)) return false;
            
            if (dx <= (rect.w / 2)) return true;
            if (dy <= (rect.h / 2)) return true;
            
            const cornerDist = (dx - rect.w / 2) ** 2 + (dy - rect.h / 2) ** 2;
            return cornerDist <= (circle.size ** 2);
        }

        // Initialize on page load
        console.log("Page loaded, ready to start");
    </script>
</body>
</html>
